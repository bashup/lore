#!/usr/bin/env bash
# ---
# This file is automatically generated from lore.md - DO NOT EDIT
# ---

# MIT License
#
# Copyright (c) 2021 PJ Eby
#
# Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation
# files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy,
# modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software
# is furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
# WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
# COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
# ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

declare -gx LORE_SOURCE="${LORE_SOURCE:-$BASH_SOURCE}"
lore() {
	local REPLY; declare -F lore::on-load &>/dev/null || source "$LORE_SOURCE" --
	(($#)) || set -- help;
	! declare -F lore."$1" &>/dev/null || { lore."$@"; return; }
	case $1 in
	--) shift; ((!$#)) || lore "$@";;  # no-op if no subsequent args
	-h|--help) lore help ;;
	*) return 64  # XXX alias lookup, error handling
	;;
	esac
}
export -f lore
lore.status() {
	local REPLY is_on=ON; lore::enabled || is_on=off;
	lore::format-histfile
	printf "lore is %s, in '%s' mode; HISTFILE=%s\\n" "$is_on" "${LORE_MODE-auto}" "${REPLY}" >&2
	lore -- "$@"
}

lore::enabled() { [[ ${PROMPT_COMMAND-} == *'lore prompt;'* ]]; }

lore::format-histfile() { #set -x
	REPLY=${HISTFILE-}; REPLY=${REPLY/#$PWD\//}
	[[ ! ${HOME-} ]] || REPLY=${REPLY/#$HOME\//'~'/}
	REPLY="${REPLY:-''}"
}
lore.local() { history -a; lore::find-local; lore::select "$REPLY"; lore unlock "$@"; }
lore.global() { lore::find-global; lore use "$REPLY" "$@"; }
lore.use() { history -a; lore::select "${1-$PWD}"; lore lock "${@:2}"; }

lore::complete.use() {
	if (($#>1)); then lore::complete "${@:2}"; else mapfile -t COMPREPLY < <(compgen -fd "$1"); fi
}
lore.on() {	lore off; declare -gx PROMPT_COMMAND="{ lore prompt;};${PROMPT_COMMAND-}"; lore -- "$@"; }
lore.off() {
	! lore::enabled || declare -gx PROMPT_COMMAND=${PROMPT_COMMAND//\{ lore prompt;\};/}
	lore -- "$@"
}
lore.lock() { lore::set-mode locked "disabling autoselect; use 'lore unlock' to re-enable" "$@"; }

lore::set-mode() {
	if [[ ${LORE_MODE-auto} != "$1" ]]; then
		declare -gx LORE_MODE="$1"; ! lore::enabled || echo "lore: $2" >&2
	fi
	lore -- "${@:3}"
}
lore.unlock() { lore::set-mode auto "re-entering autoselect mode" "$@"; }
# Cache the last working directory so we don't search for the file
# on every single prompt
declare -g __lore_pwd=

lore.prompt() {
	if [[ ${LORE_MODE-auto} == auto && $PWD != "$__lore_pwd" ]]; then
		# Current directory changed; check for new history file
		[[ $__lore_pwd ]] || history -a
		declare -g __lore_pwd=$PWD
		if lore::find-local; [[ $REPLY != "${HISTFILE-}" ]]; then
			set -- "$REPLY"	"$@" # Save the new history file's name
			if lore::find-global; [[ $REPLY == "${HISTFILE-}" ]]; then
				history -a   # Only save directory-changing commands to global history
			fi
			lore::select "$1"	# Load the new history file
			shift
		fi
	fi
	history -a   # save last command(s)
	lore -- "$@"
}
lore.save() {
	history -a  # save current history to current file
	if (($#)); then
		case $1 in -f) set -- "${2-.}" "$1" ;; esac
		lore::to-file "$1"
		if [[ -f "$REPLY" && ${2-} != "-f" ]]; then
			echo "lore: $REPLY already exists; use 'lore save $1 -f' to overwrite" >&2
			return 73  # EX_CANTCREAT
		else
			history -w "$REPLY"
			declare -g __lore_pwd=
		fi
	fi
}
lore::complete.save() {
	if (($#==2)); then COMPREPLY=(-f); else mapfile -t COMPREPLY < <(compgen -fd "$1"); fi
}
lore.edit() {
	lore::current-history
	[[ -f "$REPLY" ]] || touch "$REPLY"
	history -a  # save any unwritten history
	"${LORE_EDITOR:-${EDITOR:-lore::no-editor}}" "$REPLY"
	lore reload
	lore -- "$@"
}
lore::no-editor() { echo "No LORE_EDITOR or EDITOR set; file '$1' unchanged" >&2; }
lore::current-history() { REPLY=${HISTFILE-}; [[ $REPLY ]] || lore::find-local; }
lore.reload() {
	history -a  # save current history to current file
	lore::current-history
	declare -g HISTFILE=
	lore::select "$REPLY"
	lore -- "$@"
}
lore::select() {
	lore::abspath "$1"; lore::to-file "$REPLY"
	if [[ $REPLY != "${HISTFILE-}" ]]; then
		# Clear current history and load the new one
		history -c
		declare -g HISTFILE=$REPLY; lore::format-histfile
		echo "lore: loading history from $REPLY" >&2
		history -r
	fi
}
declare -g __lore_tmux_cache=("" "" "")

lore::find-global() {
	REPLY=${LORE_GLOBAL:-$HOME/.bash_history};
	[[ ${TMUX_PANE-} && ! ${LORE_DISABLE_TMUX-} ]] || return 0
	[[ ${LORE_TMUX_FILE-} ]] || local LORE_TMUX_FILE="w#Ip#{pane_index}"
	[[ ${LORE_TMUX_DIR-} ]] || {
		local LORE_TMUX_DIR=$HOME/.lore-tmux
		[[ ! ${XDG_CONFIG_HOME-} ]] || LORE_TMUX_DIR=$XDG_CONFIG_HOME/lore-tmux
	}
	[[ -d "$LORE_TMUX_DIR" ]] || mkdir -p "$LORE_TMUX_DIR"
	set -- "${__lore_tmux_cache[@]}" . . .
	if [[ $TMUX_PANE != "$1" || $LORE_TMUX_FILE != "$2" ]]; then
		set -- "$TMUX_PANE" "$LORE_TMUX_FILE" \
			"$(tmux display-message -pt "$TMUX_PANE" "$LORE_TMUX_FILE")"
		__lore_tmux_cache=("$@")
	fi
	REPLY="${LORE_TMUX_DIR}/$3"
}
lore::find-local() {
	lore::abspath "${1-$PWD}"; set -- "$REPLY"
	while true; do
		# Search up to find nearest local history file
		REPLY=${1%/}/${LORE_FILE-.lore}; [[ ! -f "$REPLY" ]] || return 0;
		# Any parent directories left?  If not, go global
		if ! [[ $1 =~ /+[^/]+/*$ ]]; then lore::find-global; return; fi
		# Strip one directory name and continue
		set -- "${1%${BASH_REMATCH[0]}}"; set -- "${1:-/}";
	done
}
lore::abspath() {
	[[ $1 == /* ]] || set -- "${PWD%/}/$1/"
	while [[ $1 = */./* ]]; do set --  "${1//\/.\//\/}"; done
	while [[ $1 =~ ([^/][^/]*/\.\.(/|$)) ]]; do set -- "${1/${BASH_REMATCH[0]}/}"; done
	while [[ $1 == */ && $1 != // && $1 != / ]]; do set -- "${1%/}"; done
	REPLY=$1
}
lore::to-file() { REPLY=$1; [[ ! -d $REPLY ]] || REPLY=${REPLY%/}/${LORE_FILE-.lore}; }
lore::complete() {
	while (($#>1)); do
		if declare -F lore::complete."$1" &>/dev/null; then
			lore::complete."$@"; return
		fi
		shift
	done
	mapfile -t COMPREPLY < <(compgen -A function lore."${1-}")
	COMPREPLY=("${COMPREPLY[@]#lore.}")
}
lore::_complete() { COMPREPLY=(); lore::complete "${COMP_WORDS[@]:0:COMP_CWORD+1}"; }
complete -F lore::_complete lore
lore::on-load() {
	if [[ ${BASH_SOURCE[1]} == "$0" ]]; then
		printf "lore must be sourced into your shell before use; try 'source %q' first\\n" "$0" >&2
		exit 64 # EX_USAGE
	fi
	if (($#)); then lore "$@"; fi
}

lore::on-load "$@"
