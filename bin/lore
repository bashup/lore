#!/usr/bin/env bash
# ---
# This file is automatically generated from lore.md - DO NOT EDIT
# ---

# MIT License
#
# Copyright (c) 2021 PJ Eby
#
# Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation
# files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy,
# modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software
# is furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
# WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
# COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
# ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

export LORE_SOURCE="${LORE_SOURCE-$BASH_SOURCE}"
lore() {
	local REPLY; declare -F lore::loaded &>/dev/null || source "$LORE_SOURCE" --
	(($#)) || set -- help;
	! declare -F lore."$1" &>/dev/null || { lore."$@"; return; }
	case $1 in
	--) shift; ((!$#)) || lore "$@";;  # no-op if no subsequent args
	-h|--help) lore help ;;
	*) return 64  # XXX alias lookup, error handling
	;;
	esac
}
export -f lore
lore.status() {
	local is_on=ON; [[ ${PROMPT_COMMAND-} == *'lore prompt;'* ]] || is_on=off;
	printf "lore is %s, in '%s' mode; HISTFILE=%q\\n" "$is_on" "${LORE_MODE-auto}" "${HISTFILE-}"
}
lore.on() {	lore off; declare -gx PROMPT_COMMAND="{ lore prompt;};${PROMPT_COMMAND-}"; }
lore.off() {
	[[ ! ${PROMPT_COMMAND-} ]] || declare -gx PROMPT_COMMAND=${PROMPT_COMMAND//\{ lore prompt;\};/}
}
# Cache the last working directory so we don't search for the file
# on every single prompt
declare -g __lore_pwd=

lore.prompt() {
	# Record current history and select local history file if needed
	if [[ ${LORE_MODE-auto} == auto && $PWD != "$__lore_pwd" ]]; then
		if lore::find-local; [[ $REPLY != "${HISTFILE-}" ]]; then
			# Switch files, but don't save the command that did the switching
			lore::select "$REPLY"
			return
		fi
		declare -g __lore_pwd=$PWD
	fi
	history -a   # save last command(s)
}
lore::select() {
	lore::abspath "$1"; lore::to-file "$REPLY"
	if [[ $REPLY != "${HISTFILE-}" ]]; then
		# Clear current history and load the new one
		history -c; declare -g HISTFILE=$REPLY; history -r
	fi
}
declare -g __lore_tmux_cache=("" "" "")

lore::find-global() {
	REPLY=${LORE_GLOBAL:-$HOME/.bash_history};
	[[ ${TMUX_PANE-} && ! ${LORE_DISABLE_TMUX-} ]] || return 0
	[[ ${LORE_TMUX_FILE-} ]] || local LORE_TMUX_FILE="w#Ip#{pane_index}"
	[[ ${LORE_TMUX_DIR-} ]] || {
		local LORE_TMUX_DIR=$HOME/.lore-tmux
		[[ ! ${XDG_CONFIG_HOME-} ]] || LORE_TMUX_DIR=$XDG_CONFIG_HOME/lore-tmux
	}
	[[ -d "$LORE_TMUX_DIR" ]] || mkdir -p "$LORE_TMUX_DIR"
	set -- "${__lore_tmux_cache[@]}" . . .
	if [[ $TMUX_PANE != "$1" || $LORE_TMUX_FILE != "$2" ]]; then
		set -- "$TMUX_PANE" "$LORE_TMUX_FILE" \
			"$(tmux display-message -pt "$TMUX_PANE" "$LORE_TMUX_FILE")"
		__lore_tmux_cache=("$@")
	fi
	REPLY="${LORE_TMUX_DIR}/$3"
}
lore::find-local() {
	lore::abspath "${1-$PWD}"; set -- "$REPLY"
	while true; do
		# Search up to find nearest local history file
		REPLY=${1%/}/${LORE_FILE-.lore}; [[ ! -f "$REPLY" ]] || return 0;
		# Any parent directories left?  If not, go global
		if ! [[ $1 =~ /+[^/]+/*$ ]]; then lore::find-global; return; fi
		# Strip one directory name and continue
		set -- "${1%${BASH_REMATCH[0]}}"; set -- "${1:-/}";
	done
}
lore::abspath() {
	[[ $1 == /* ]] || set -- "${PWD%/}/$1/"
	while [[ $1 = */./* ]]; do set --  "${1//\/.\//\/}"; done
	while [[ $1 =~ ([^/][^/]*/\.\.(/|$)) ]]; do set -- "${1/${BASH_REMATCH[0]}/}"; done
	while [[ $1 == */ && $1 != // && $1 != / ]]; do set -- "${1%/}"; done
	REPLY=$1
}
lore::to-file() { REPLY=$1; [[ ! -d $REPLY ]] || REPLY=${REPLY%/}/${LORE_FILE-.lore}; }
lore::loaded() { :; }
[[ $BASH_SOURCE != "$0" ]] || {
	printf "lore must be sourced into your shell before use; try 'source %q' first\\n" "$0" >&2
	exit 64 # EX_USAGE
}
((!$#)) || lore "$@"
